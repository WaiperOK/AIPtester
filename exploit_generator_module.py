# exploit_generator_module.py
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog # filedialog не используется здесь сейчас
import os # os не используется здесь сейчас
import json
import traceback
import threading

def create_tab(tab_frame, api_service, selected_model_var, status_setter, theme_colors, dynamic_font_widgets_list):
    scrolledtext_bg = theme_colors.get("scrolledtext_bg", "#1e1e1e")
    scrolledtext_fg = theme_colors.get("scrolledtext_fg", "white")
    text_font_to_use = theme_colors.get("text_font")

    frame = ttk.Frame(tab_frame); frame.pack(fill="both", expand=True)
    top_frame = ttk.Frame(frame); top_frame.pack(fill="x", pady=(0,10))

    ttk.Label(top_frame, text="Тип уязвимости:").grid(row=0, column=0, sticky="w", padx=(0,5), pady=2)
    ex_vuln_combo = ttk.Combobox(top_frame, width=37, font=text_font_to_use, values=[
        "Buffer Overflow", "ROP Chain", "Format String", "Use-After-Free", "Race Condition",
        "Heap Overflow", "Integer Overflow", "SQL Injection", "XSS Reflected", "Command Injection" # Добавил еще
    ], state="readonly")
    ex_vuln_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
    if ex_vuln_combo["values"]: ex_vuln_combo.current(0)

    top_frame.columnconfigure(1, weight=1)
    ex_generate_button = ttk.Button(top_frame, text="Рекомендации по эксплойту (AI)")
    ex_generate_button.grid(row=0, column=2, padx=5, pady=2, sticky="ns") # Изменил column

    ex_explain_button = ttk.Button(top_frame, text="Объяснить вывод (AI)")
    ex_explain_button.grid(row=0, column=3, padx=5, pady=2, sticky="ns") # Рядом с генерацией

    results_control_frame = ttk.Frame(frame); results_control_frame.pack(fill="x", pady=(2,2))
    def copy_results():
        content = ex_exploit_text.get("1.0", tk.END).strip()
        if content:
            try: tab_frame.clipboard_clear(); tab_frame.clipboard_append(content); status_setter("Текст скопирован.")
            except tk.TclError as e_clip: status_setter(f"Ошибка буфера: {e_clip}"); messagebox.showwarning("Буфер обмена", f"Не удалось: {e_clip}", parent=tab_frame)
        else: status_setter("Нет текста для копирования.")
    copy_button = ttk.Button(results_control_frame, text="Копировать вывод", command=copy_results)
    copy_button.pack(side=tk.RIGHT, padx=0)

    ex_exploit_text = scrolledtext.ScrolledText(frame, height=15, bg=scrolledtext_bg, fg=scrolledtext_fg, wrap=tk.WORD, relief="solid", bd=1, font=text_font_to_use)
    dynamic_font_widgets_list.append(ex_exploit_text)
    ex_exploit_text.pack(fill="both", expand=True)
    ex_exploit_text.insert(tk.END, "AI предоставит структуру/шаблон эксплойта или PoC для выбранного типа уязвимости.\n")

    def _exploit_thread_worker(vuln_type_param):
        status_setter(f"Генерация эксплойта/PoC для '{vuln_type_param}'...")
        ex_exploit_text.delete(1.0, tk.END)
        try:
            if not api_service or not hasattr(api_service, 'generate_exploit'):
                 ex_exploit_text.insert(tk.END, "AI сервис не инициализирован или метод 'generate_exploit' не найден.\n"); status_setter("Ошибка AI сервиса."); return
            result = api_service.generate_exploit(vuln_type_param) # model_to_use убран
            if isinstance(result, dict) and "error" in result:
                ex_exploit_text.insert(tk.END, f"Ошибка API: {result['error']}\n")
                if result.get("status_code"): ex_exploit_text.insert(tk.END, f"Status Code: {result['status_code']}\n")
            elif isinstance(result, dict) and result.get("status") == "success" and "exploit_code" in result:
                guidance = result.get("exploit_code", "")
                if guidance: ex_exploit_text.insert(tk.END, guidance); status_setter("Эксплойт/PoC успешно сгенерирован.")
                else: ex_exploit_text.insert(tk.END, "API вернуло пустой ответ.\n"); status_setter("Не удалось сгенерировать.")
            else: ex_exploit_text.insert(tk.END, f"Неожиданный ответ:\n{json.dumps(result, indent=2, ensure_ascii=False)}\n"); status_setter("Ошибка генерации.")
        except Exception as e: detailed_error = traceback.format_exc(); ex_exploit_text.insert(tk.END, f"Ошибка: {str(e)}\n\n{detailed_error}\n"); status_setter(f"Критическая ошибка: {str(e)}")

    def run_exploit_generate_command():
        vuln_type = ex_vuln_combo.get()
        if not vuln_type: messagebox.showerror("Ошибка", "Выберите тип уязвимости.", parent=tab_frame); return
        ex_generate_button.config(state=tk.DISABLED); ex_explain_button.config(state=tk.DISABLED)
        def thread_target_wrapper():
            try: _exploit_thread_worker(vuln_type)
            finally:
                if tab_frame.winfo_exists():
                    tab_frame.after(0, lambda: (ex_generate_button.config(state=tk.NORMAL), ex_explain_button.config(state=tk.NORMAL)))
        threading.Thread(target=thread_target_wrapper, daemon=True).start()
    ex_generate_button.config(command=run_exploit_generate_command)

    def _explain_exploit_thread_worker(exploit_text_to_explain):
        status_setter("Объяснение эксплойта через AI...")
        ex_exploit_text.insert(tk.END, "\n\n--- ОБЪЯСНЕНИЕ ОТ AI ---\n")
        try:
            if not api_service or not hasattr(api_service, 'explain_text'):
                 ex_exploit_text.insert(tk.END, "AI сервис не инициализирован или метод 'explain_text' не найден.\n"); status_setter("Ошибка AI сервиса."); return
            result = api_service.explain_text(exploit_text_to_explain, context="этого эксплойта или PoC")
            if isinstance(result, dict) and "error" in result:
                ex_exploit_text.insert(tk.END, f"Ошибка API при объяснении: {result['error']}\n")
            elif isinstance(result, dict) and result.get("status") == "success" and "text_response" in result:
                ex_exploit_text.insert(tk.END, result.get("text_response","Не удалось получить объяснение."))
            else: ex_exploit_text.insert(tk.END, f"Неожиданный ответ при объяснении:\n{json.dumps(result, indent=2, ensure_ascii=False)}\n")
            status_setter("Объяснение эксплойта завершено.")
        except Exception as e: detailed_error = traceback.format_exc(); ex_exploit_text.insert(tk.END, f"Ошибка объяснения: {str(e)}\n\n{detailed_error}\n"); status_setter(f"Ошибка объяснения: {str(e)}")

    def run_explain_exploit_command():
        current_exploit_text = ex_exploit_text.get("1.0", tk.END).strip()
        if not current_exploit_text or "Ожидание генерации" in current_exploit_text :
            messagebox.showinfo("Информация", "Сначала сгенерируйте или вставьте текст эксплойта для объяснения.", parent=tab_frame)
            return
        ex_generate_button.config(state=tk.DISABLED); ex_explain_button.config(state=tk.DISABLED)
        def thread_target_wrapper():
            try: _explain_exploit_thread_worker(current_exploit_text)
            finally:
                if tab_frame.winfo_exists():
                    tab_frame.after(0, lambda: (ex_generate_button.config(state=tk.NORMAL), ex_explain_button.config(state=tk.NORMAL)))
        threading.Thread(target=thread_target_wrapper, daemon=True).start()
    ex_explain_button.config(command=run_explain_exploit_command)